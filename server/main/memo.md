首先启动数据库
1. 启动服务
    初始化数据库连接池,留给后续可能对数据库的访问,使用net包提供的Listen 对建立在Tcp连接上的 本地8889端口进行监听,接受连接申请.
2. 处理连接请求
    每监听到请求,开启一个goroutine去处理请求,将连接作为参数传递到goroutine中,以备传输应答,主协程继续监听
3. 对服务请求的处理
    申请4k大小的缓存接收对方发来的信息,由于本地资源有限,对大于4k的信息拒绝接收,并返回拒绝接收的原因
    每条信息发送前,首先发送信息的大小,由此获取信息的大小
    每条信息都是经过序列化后的字符串,需要进行反序列化还原数据
    所有信息都被抽象成1个Message的类 两个字段:1.MesType  2.Data
    Data是具体的请求的Message的序列化字符串
    通过对MesType的判断,将服务请求的数据交由对应的函数处理
    主要5种类型的请求 1.登录请求  2.注册请求  3.群发信息的发送  4.退出信息  5.私信的发送
    1.登录请求处理
        信息数据中包含登录用户名和密码,本地用变量接收后,传递到相应函数进行登录处理
        登录处理:从数据库连接池中取一个连接 defer一个连接关闭 到数据库中查询是否存在此用户名 如果不存在 返回相应信息给用户
        用户名存在,然后对比密码是否正确 不正确,返回错误发送给客户  正确,启动相应函数通知其他用户,该用户上线
        登录成功的返回信息中包含了在线用户的名单,
        本地维护了一个记载在线用户的map 用户名作为key 用户与服务器的连接作为value 将登陆的用户加入这个map
        这里存在一个并发安全问题,更新map时需要加锁
        其他用户在本地也存在记录在线用户的map 收到用户上下线消息后 进行更新
    2.注册消息处理
        首先检测申请注册的用户名是否存在,存在则返回提示信息,不存在则注册成功,修改数据库,由于使用内存数据库,需要进行数据持久化
        修改数据库依旧存在并发安全问题,加锁?
        返回注册成功,让其登录
    3.群发消息
        将消息接收后,遍历当前在线用户,将消息发送给每个人
    4.退出信息
        服务器收到用户退出信息后,首先更新在线用户map,然后遍历map,通知其他在线用户,其他用户收到后,更新在线用户
        这里存在一个潜在问题,就是用户被强制下线了,如断网等,不会发退出信息到服务器,服务器与客户端的连接处会报错,
        服务器根据报错类型获取信息来更新在线用户map和通知其他用户
    5.私发消息
        获取私发对象id后,首先查询对方是否在线,在线直接发送,无则到数据库中查询用户是否存在,存在则保存消息到数据库,待该
        用户上线后,发送消息到该用户,同时清空数据库中的消息.  用户在线与否,用户存在与否,发送方都能收到回复信息.
客户端:
    发送消息:1.登录 2.注册 3.群发消息 4.私发消息
    接收消息:接收各种消息